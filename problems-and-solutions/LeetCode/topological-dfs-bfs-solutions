# LeetCode - Topological DFS & BFS | Problems
* **Notations**: 
  * :heavy_check_mark: means **MUST DO (i.e., very important, typical, or good) problems** that should definitely be familiar with
  * :wavy_dash: means problems that are less typical
  * :green_book: means **EASY problems** as defined by LeetCode
  * :orange_book: means **MEDIUM problems** as defined by LeetCode
  * :closed_book: means **HARD problems** as defined by LeetCode

---

:heavy_check_mark: :orange_book: [79. Word Search](https://leetcode.com/problems/word-search/)

```
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        
        self.found = False
        m, n = len(board), len(board[0])
        
        def dfs(idx, i, j):
            
            if self.found:
                return
            
            if idx == len(word):
                self.found = True
                return
            
            if i < 0 or i >= m or j < 0 or j >= n:
                return
            
            tmp = board[i][j]
            if tmp != word[idx]:
                return
            
            board[i][j] = '#'
            
            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                dfs(idx + 1, i + dx, j + dy)
            
            board[i][j] = tmp
        
        for row in range(m):
            for col in range(n):
                if self.found:
                    return True
                dfs(0, row, col)
        
        return self.found
            
```
---

:heavy_check_mark: :orange_book: [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)

```
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        
        def dfs(row, col):
            if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != '1':
                return
            
            grid[row][col] = '#'
            
            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                dfs(row + dx, col + dy)
            
        if not grid or not grid[0]:
            return 0

        result = 0
        
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == '1':
                    dfs(row, col)
                    result += 1

        return result
```

---

:heavy_check_mark: :orange_book: [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)

```
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        
        fresh = 0
        rotten = deque() # for BFS on each rotten orange
        
        # first pass through the grid to get initialized info
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == 2:
                    rotten.append((row, col))
                elif grid[row][col] == 1:
                    fresh += 1
                
        time = 0
        
        # while there is rotten in the queue and there is still fresh orange
        while rotten and fresh > 0:
            time += 1
            
            for _ in range(len(rotten)):
                row, col = rotten.popleft()
                for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                    new_row, new_col = row + dx, col + dy
                    if new_row < 0 or new_row >= len(grid) or new_col < 0 or new_col >= len(grid[0]):
                        continue
                    if grid[new_row][new_col] == 0 or grid[new_row][new_col] == 2:
                        continue
                        
                    fresh -= 1
                    grid[new_row][new_col] = 2 # fresh orange becomes rotten
                    rotten.append((new_row, new_col))

        return time if fresh == 0 else -1
```

---

:heavy_check_mark: :orange_book: [417. Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)

```

```

---
